#include <cmath>
#include <cstdio>
#include <fstream>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

#include "Driver.h"
// Assuming these are generated by ANTLR4 and available in the include path
#include "CalcFis/CalcFisLexer.h"
#include "CalcFis/CalcFisParser.h"

#include "llvm/IR/PassManager.h"
#include "llvm/Passes/PassBuilder.h"
#include "llvm/Transforms/InstCombine/InstCombine.h"
#include "llvm/Transforms/Scalar.h"
#include "llvm/Transforms/Scalar/GVN.h"
#include "llvm/Transforms/Scalar/Reassociate.h"
#include "llvm/Transforms/Scalar/SimplifyCFG.h"

#include "llvm/IR/Verifier.h"
#include "llvm/Support/Error.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/TargetSelect.h"
#include "llvm/Support/raw_ostream.h"

#include "llvm/Bitcode/BitcodeReader.h"
#include "llvm/Bitcode/BitcodeWriter.h"
#include "llvm/Support/MemoryBuffer.h"

#include "llvm/ExecutionEngine/JITSymbol.h"
#include "llvm/ExecutionEngine/Orc/ExecutionUtils.h"
#include "llvm/ExecutionEngine/Orc/LLJIT.h"
#include "llvm/ExecutionEngine/Orc/ThreadSafeModule.h"

using namespace antlr4;
using namespace std;

int main(int argc, const char *argv[]) {
  ifstream ifile;
  if (argc > 1) {
    ifile.open(argv[1]);
    if (!ifile.is_open()) {
      cerr << "No se pudo aperturar o leer el archivo de entrada." << endl;
      return -1;
    }
  }

  istream &stream = argc > 1 ? ifile : cin;

  ANTLRInputStream input(stream);
  CalcFisLexer lexer(&input);
  CommonTokenStream tokens(&lexer);
  CalcFisParser parser(&tokens);

  tree::ParseTree *tree = parser.prog();

  // Driver para CalcFis
  auto driver = new CalcFisDriver();
  driver->visit(tree);

  // Obtener el módulo LLVM del driver
  std::unique_ptr<llvm::Module> module = driver->getModule();

  // Verificar validez del módulo antes de optimizar
  if (llvm::verifyModule(*module, &llvm::errs())) {
    llvm::errs() << "El módulo LLVM es inválido. Verificación falló.\n";
    delete driver;
    return -1;
  }
  if (!module->getFunction("main")) {
    llvm::errs() << "No hay función 'main' en el módulo.\n";
    delete driver;
    return -1;
  }

  // Análisis/optimización por función
  llvm::LoopAnalysisManager LAM;
  llvm::FunctionAnalysisManager FAM;
  llvm::CGSCCAnalysisManager CGAM;
  llvm::ModuleAnalysisManager MAM;
  llvm::PassBuilder PB;
  PB.registerModuleAnalyses(MAM);
  PB.registerFunctionAnalyses(FAM);
  PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);

  llvm::FunctionPassManager FPM;
  FPM.addPass(llvm::InstCombinePass());
  FPM.addPass(llvm::ReassociatePass());
  FPM.addPass(llvm::GVNPass());
  FPM.addPass(llvm::SimplifyCFGPass());

  // Guardar sin optimizar
  {
    std::error_code EC;
    llvm::raw_fd_ostream out("sinopt.ll", EC);
    module->print(out, nullptr);
  }

  // Optimizar
  std::cout << "Iniciando optimización..." << std::endl;
  for (auto &F : *module) {
    if (!F.isDeclaration()) {
      std::cout << "Optimizando función: " << F.getName().str() << std::endl;
      FPM.run(F, FAM);
    }
  }
  std::cout << "Optimización completada." << std::endl;

  // Guardar optimizado
  {
    std::error_code EC;
    llvm::raw_fd_ostream out("opt.ll", EC);
    if (EC) {
      std::cerr << "Error al abrir opt.ll: " << EC.message() << std::endl;
    } else {
      module->print(out, nullptr);
      std::cout << "opt.ll generado exitosamente." << std::endl;
    }
  }

  try {
    // Inicializar el target nativo
    llvm::InitializeNativeTarget();
    llvm::InitializeNativeTargetAsmPrinter();
    llvm::InitializeNativeTargetAsmParser();

    // Crear JIT
    auto JIT = llvm::orc::LLJITBuilder().create();
    if (!JIT) {
      llvm::errs() << "No se pudo crear LLJIT\n";
      delete driver;
      return -1;
    }
    auto &LL = *JIT; // Desreferenciar Expected

    // Alinear DataLayout del módulo original
    module->setDataLayout(LL->getDataLayout());

    // Resolver automáticamente símbolos del proceso actual (printf, pow, etc.)
    auto &JD = LL->getMainJITDylib();
    auto Gen = llvm::orc::DynamicLibrarySearchGenerator::GetForCurrentProcess(
        LL->getDataLayout().getGlobalPrefix());
    if (!Gen) {
      llvm::errs() << "No se pudo crear DynamicLibrarySearchGenerator\n";
      delete driver;
      return -1;
    }
    JD.addGenerator(std::move(*Gen));

    // Transferencia robusta: serializar a bitcode y reparsear en un nuevo
    // contexto
    llvm::SmallVector<char, 0> Buffer;
    llvm::raw_svector_ostream OS(Buffer);
    llvm::WriteBitcodeToFile(*module, OS);

    auto NewCtx = std::make_unique<llvm::LLVMContext>();
    auto MB = llvm::MemoryBuffer::getMemBuffer(
        llvm::StringRef(Buffer.data(), Buffer.size()));
    auto ExpectedMod = llvm::parseBitcodeFile(MB->getMemBufferRef(), *NewCtx);
    if (!ExpectedMod) {
      llvm::errs() << "No se pudo reparsear bitcode al nuevo contexto\n";
      delete driver;
      return -1;
    }
    std::unique_ptr<llvm::Module> NewModule = std::move(*ExpectedMod);
    NewModule->setDataLayout(LL->getDataLayout());

    // Encapsular el módulo en ThreadSafeModule con su nuevo contexto
    auto TSM =
        llvm::orc::ThreadSafeModule(std::move(NewModule), std::move(NewCtx));

    // Añadir el módulo al JIT con mensaje de error detallado
    if (auto Err = LL->addIRModule(std::move(TSM))) {
      llvm::errs() << "Error al agregar el módulo al JIT: "
                   << llvm::toString(std::move(Err)) << "\n";
      delete driver;
      return -1;
    }

    // Buscar la función main
    auto Sym = LL->lookup("main");
    if (!Sym) {
      llvm::errs() << "No se encontró 'main' en el JIT\n";
      delete driver;
      return -1;
    }

    // Invocar main como una función C que retorna int y no toma args
    using MainFnTy = int (*)();
    MainFnTy MainPtr = Sym->toPtr<MainFnTy>();
    int ret = MainPtr();

    // Mostrar el resultado de ejecución JIT
    std::cout << "[JIT] main() retornó: " << ret << std::endl;

    // Liberar el driver al final
    delete driver;
  } catch (const std::exception &e) {
    std::cerr << "Excepción en JIT: " << e.what() << std::endl;
    delete driver;
    return -1;
  }

  return 0;
}